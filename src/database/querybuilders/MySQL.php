<?php

namespace src\database\querybuilders;

use DateTime;
use src\database\objects\Join;
use src\database\objects\OrderBy;
use src\database\objects\Where;
use src\database\queries\Query;

class MySQL implements QueryBuilderInterface
{
    public function select(string $table, array $columns, bool $escapeColumns, array $joins, array $where, array $orderBys, ?int $limit, ?int $offset): array
    {
        $query = '';
        $params = [];

        $query .= sprintf('SELECT %s FROM `%s`', $this->generateColumnsString($columns, $escapeColumns), $table);

        if ($joins) {
            $query .= ' ';
            $query .= $this->generateJoinsString($table, $joins);
        }

        if ($where) {
            $query .= sprintf(' WHERE %s', $this->generateWhereString($where));

            array_push($params, ...$this->extractWhereValues($where));
        }

        if ($orderBys) {
            $query .= sprintf(' %s', $this->generateOrderByString($orderBys));
        }

        if ($limit) {
            $query .= sprintf(' LIMIT %s', $limit);
        }

        if ($offset) {
            $query .= sprintf(' OFFSET %s', $offset);
        }

        $query .= ';';

        return [
            $query,
            $this->castParams($params)
        ];
    }

    public function insert(string $table, array $values): array
    {
        $query = sprintf(
            'INSERT INTO `%s` (%s) VALUES (%s);',
            $table,
            $this->generateColumnsString(array_keys($values), true),
            $this->generatePlaceholdersString(count($values))
        );

        return [
            $query,
            $this->castParams(array_values($values))
        ];
    }

    public function update(string $table, array $values, array $where): array
    {
        $query = '';
        $params = [];

        $query .= sprintf('UPDATE `%s` SET %s', $table, $this->generateUpdateString($values));
        array_push($params, ...array_values($values));

        if ($where) {
            $query .= sprintf(' WHERE %s', $this->generateWhereString($where));

            array_push($params, ...$this->extractWhereValues($where));
        }

        $query .= ';';

        return [
            $query,
            $this->castParams($params)
        ];
    }

    public function delete(string $table, array $where, array $orderBys, ?int $limit): array
    {
        $query = '';
        $params = [];

        $query .= sprintf('DELETE FROM `%s`', $table);

        if ($where) {
            $query .= sprintf(' WHERE %s', $this->generateWhereString($where));

            array_push($params, ...$this->extractWhereValues($where));
        }

        if ($orderBys) {
            $query .= sprintf(' %s', $this->generateOrderByString($orderBys));
        }

        if ($limit) {
            $query .= sprintf(' LIMIT %s', $limit);
        }

        $query .= ';';

        return [
            $query,
            $this->castParams($params)
        ];
    }

    public function createTable(string $table, bool $ifNotExists, array $properties, string $primaryKey, bool $primaryKeyAutoGenerated): array
    {
        $query = '';
        $params = [];

        $query .= sprintf(
            'CREATE TABLE%s `%s`(',
            ($ifNotExists ? ' IF NOT EXISTS' : ''),
            $table
        );

        $columns = [];
        $columns[] = sprintf(
            '`%s` %s NOT NULL%s',
            $primaryKey,
            $this->getColumnType($properties[$primaryKey]->type, true),
            ($primaryKeyAutoGenerated ? ' AUTO_INCREMENT' : '')
        );

        foreach ($properties as $name => $property) {
            if ($name == $primaryKey) {
                continue;
            }

            $type = $this->getColumnType($property->type, false);
            if (!$type) {
                continue;
            }

            $columns[] = sprintf(
                '`%s` %s %s',
                $name,
                $type,
                ($property->allowsNull ? 'NULL' : 'NOT NULL')
            );
        }

        $columns[] = sprintf('PRIMARY KEY (`%s`)', $primaryKey);

        $query .= sprintf(' %s );', implode(' , ', $columns));

        return [
            $query,
            $this->castParams($params)
        ];
    }

    public function createDatabase(string $database, bool $ifNotExists): array
    {
        $query = '';
        $params = [];

        $query .= sprintf(
            'CREATE DATABASE%s `%s`;',
            (($ifNotExists) ? ' IF NOT EXISTS' : ''),
            $database
        );

        return [
            $query,
            $this->castParams($params)
        ];
    }

    public function useDatabase(string $database): array
    {
        $query = '';
        $params = [];

        $query .= sprintf(
            'USE `%s`;',
            $database
        );

        return [
            $query,
            $this->castParams($params)
        ];
    }

    public function castToDatabase(mixed $value): mixed
    {
        if ($value instanceof DateTime) {
            return $value->format('Y-m-d H:i:s');
        }

        if (is_bool($value)) {
            return ($value) ? 1 : 0;
        }

        return $value;
    }

    public function castFromDatabase(string $nativeType, mixed $value): mixed
    {
        if (is_null($value)) {
            return null;
        }

        if ($nativeType == 'DATETIME') {
            return DateTime::createFromFormat('Y-m-d H:i:s', $value);
        }

        if ($nativeType == 'TINY') {
            return ($value == 1);
        }

        return $value;
    }

    public function getColumnType(string $varType, bool $isPrimaryKey): ?string
    {
        if ($varType == 'string' && $isPrimaryKey) {
            return 'VARCHAR(128)';
        }

        $types = [
            'bool' => 'TINYINT',
            'int' => 'INT',
            'float' => 'FLOAT',
            'string' => 'TEXT',
            'DateTime' => 'DATETIME'
        ];

        return $types[$varType] ?? null;
    }

    public function getColumnWithNamespace(string $table, string $column, bool $escapeColumns): string
    {
        if ($escapeColumns) {
            return sprintf('`%s`.`%s`', $table, $column);
        }

        return sprintf('%s.%s', $table, $column);
    }

    protected function generateColumnsString(array $columns, bool $escapeColumns): string
    {
        if (!$columns) {
            return '*';
        }

        $escapedColumns = array_map(
            function (string $column) use ($escapeColumns): string {
                return ($escapeColumns)
                    ? sprintf('`%s`', $column)
                    : $column;
            },
            $columns
        );

        return implode(', ', $escapedColumns);
    }

    protected function generateWhereString(array $whereConditions): string
    {
        $conditions = [];

        foreach ($whereConditions as $where) {
            if (in_array($where, ['AND', 'OR'])) {
                $conditions[] = $where;
                continue;
            }

            $key = ($where->escapeKey) ? sprintf('`%s`', $where->key) : $where->key;

            if (is_null($where->value)) {
                $conditions[] = sprintf(
                    '%s %s',
                    $key,
                    (($where->comparator == Query::EQUALS) ? 'IS NULL' : 'IS NOT NULL')
                );
                continue;
            }

            if (is_array($where->value)) {
                $conditions[] = sprintf(
                    '%s %s (%s)',
                    $key,
                    (($where->comparator == Query::IN_ARRAY) ? 'IN' : 'NOT IN'),
                    $this->generatePlaceholdersString(count($where->value))
                );
                continue;
            }

            $conditions[] = sprintf(
                '%s %s ?',
                $key,
                $where->comparator
            );
        }

        return implode(' ', $conditions);
    }

    protected function generatePlaceholdersString(int $size): string
    {
        $placeholders = [];

        for ($i = 0; $i < $size; $i++) {
            $placeholders[] = '?';
        }

        return implode(', ', $placeholders);
    }

    protected function generateUpdateString(array $values): string
    {
        $updates = [];

        foreach ($values as $key => $value) {
            $updates[] = sprintf(
                '`%s` = ?',
                $key
            );
        }

        return implode(', ', $updates);
    }

    protected function extractWhereValues(array $whereObjects): array
    {
        $values = [];

        foreach ($whereObjects as $whereObject) {
            if (!($whereObject instanceof Where)) {
                continue;
            }

            if (is_null($whereObject->value)) {
                continue;
            }

            if (is_array($whereObject->value)) {
                array_push($values, ...$whereObject->value);
                continue;
            }

            $values[] = $whereObject->value;
        }

        return $values;
    }

    protected function generateJoinsString(string $parentTable, array $joins): string
    {
        $joinStrings = [];

        foreach ($joins as $join) {
            /** @var Join $join */

            $joinStrings[] = sprintf(
                '%s `%s` ON `%s`.`%s` = `%s`.`%s`',
                $join->joinType,
                $join->joinTable,
                $parentTable,
                $join->relationTableColumnName,
                $join->joinTable,
                $join->joinTableColumnName
            );
        }

        return implode(' ', $joinStrings);
    }

    protected function generateOrderByString(array $orderBys): string
    {
        return sprintf(
            'ORDER BY %s',
            implode(
                ', ',
                array_map(
                    function (OrderBy $orderBy) {
                        return sprintf(
                            '`%s` %s',
                            $orderBy->columnName,
                            $orderBy->orderType
                        );
                    },
                    $orderBys
                )
            )
        );
    }

    protected function castParams(array $params): array
    {
        return array_map(
            function (mixed $param): mixed {
                return $this->castToDatabase($param);
            },
            $params
        );
    }
}
