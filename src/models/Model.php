<?php

namespace src\models;

use Throwable;
use PDO;
use PDOStatement;
use ReflectionClass;
use ReflectionProperty;
use src\database\Database;
use src\database\objects\Property;
use src\database\queries\Query;
use src\database\querybuilders\QueryBuilderInterface;
use src\exceptions\IdentifierException;
use src\exceptions\RelationException;
use src\exceptions\ValidationException;
use src\models\relations\Relation;

abstract class Model
{
    protected Database $database;
    protected ?QueryBuilderInterface $queryBuilder = null;
    protected string $table = '';
    protected string $primaryKeyPropertyName = 'id';
    protected bool $primaryKeyAutoGenerated = true;
    protected array $columns = [
        'id' => 'id'
    ];

    protected array $onSave = [];
    protected array $relations = [];

    public static function getTable(): ?string
    {
        return (new ReflectionClass(static::class))
            ->getProperty('table')
            ->getDefaultValue();
    }

    public function __construct(Database $database)
    {
        $this->database = $database;

        $this->registerRelations();
    }

    public function __toString(): string
    {
        return (string) $this->getPrimaryKeyValue();
    }

    public function hydrate(int|string|null $primaryKeyValue = null): static
    {
        $pkColumnName = $this->getPrimaryKeyColumnName();
        $pkValue = $primaryKeyValue ?? $this->getPrimaryKeyValue();

        $statement = $this->database->query()
            ->table($this->table)
            ->columns(array_values($this->columns))
            ->where(
                $pkColumnName,
                Query::EQUALS,
                $pkValue
            )
            ->select();

        $data = $statement->fetch(PDO::FETCH_ASSOC);

        if (!$data) {
            throw new IdentifierException(sprintf('id: %s does not exist', $pkValue));
        }

        foreach ($data as $key => $value) {
            $type = $this->getColumnType($statement, $data, $key);

            $modelPropertyName = array_search($key, $this->columns);

            if (!$modelPropertyName) {
                continue;
            }

            $this->{$modelPropertyName} = $this->castFromDatabaseToModel($type, $value);
        }

        return $this;
    }

    public function hydrateByColumn(string $column, mixed $value): static
    {
        $statement = $this->database->query()
            ->table($this->table)
            ->columns(array_values($this->columns))
            ->where(
                $column,
                Query::EQUALS,
                $value
            )
            ->select();

        $data = $statement->fetch(PDO::FETCH_ASSOC);

        if (!$data) {
            throw new IdentifierException(sprintf('%s: %s does not exist', $column, $value));
        }

        foreach ($data as $key => $value) {
            $type = $this->getColumnType($statement, $data, $key);

            $modelPropertyName = array_search($key, $this->columns);

            if (!$modelPropertyName) {
                continue;
            }

            $this->{$modelPropertyName} = $this->castFromDatabaseToModel($type, $value);
        }

        return $this;
    }

    public function hydrateByAssoc(PDOStatement $statement, array $data): static
    {
        foreach ($data as $key => $value) {
            $type = $this->getColumnType($statement, $data, $key);

            $modelPropertyName = array_search($key, $this->columns);

            if (!$modelPropertyName) {
                continue;
            }

            $this->{$modelPropertyName} = $this->castFromDatabaseToModel($type, $value);
        }

        return $this;
    }

    public function insert(): ?static
    {
        $this->onInsertOrUpdate();

        $valid = $this->validate();
        if (!$valid) {
            return null;
        }

        $insertableValues = $this->getColumns(!$this->primaryKeyAutoGenerated);

        $query = $this->database->query()
            ->table($this->table)
            ->values($insertableValues);

        if ($this->primaryKeyAutoGenerated) {
            $primaryKeyColumnName = $this->getPrimaryKeyColumnName();
            $insertedId = $query->insertWithLastId($primaryKeyColumnName);

            $this->{$primaryKeyColumnName} = $insertedId;
        } else {
            $query->insert();
        }

        return $this;
    }

    public function update(): ?static
    {
        $this->onInsertOrUpdate();

        $valid = $this->validate();
        if (!$valid) {
            return null;
        }

        $updatableValues = $this->getColumns(false);

        $pkColumnName = $this->getPrimaryKeyColumnName();
        $pkValue = $this->getPrimaryKeyValue();

        $this->database->query()
            ->table($this->table)
            ->values($updatableValues)
            ->where(
                $pkColumnName,
                Query::EQUALS,
                $pkValue
            )
            ->update();

        return $this;
    }

    public function delete(): static
    {
        $pkColumnName = $this->getPrimaryKeyColumnName();
        $pkValue = $this->getPrimaryKeyValue();

        $this->database->query()
            ->table($this->table)
            ->where(
                $pkColumnName,
                Query::EQUALS,
                $pkValue
            )
            ->delete();

        return $this;
    }

    public function undoDelete(): static
    {
        $insertableValues = $this->getColumns(true);

        $this->database->query()
            ->table($this->table)
            ->values($insertableValues)
            ->insert();

        return $this;
    }

    public function getColumnNames(): array
    {
        return array_values($this->columns);
    }

    public function getPrimaryKeyColumnName(): string
    {
        return $this->columns[$this->primaryKeyPropertyName];
    }

    public function getPrimaryKeyValue(): null|int|float|string
    {
        if (!(new ReflectionProperty($this, $this->primaryKeyPropertyName))->isInitialized($this)) {
            return null;
        }

        return $this->{$this->primaryKeyPropertyName};
    }

    public function exportAsRecord(): array
    {
        $data = [];

        foreach ($this->columns as $propertyName => $columnName) {
            if (!(new ReflectionProperty($this, $propertyName))->isInitialized($this)) {
                $data[$columnName] = null;
            }

            $data[$columnName] = $this->castFromModelToDatabase($this->{$propertyName});
        }

        return $data;
    }

    public function createTable(bool $ifNotExists = false): PDOStatement
    {
        if (!$this->queryBuilder) {
            $this->queryBuilder = $this->database->getQueryBuilder();
        }

        $properties = [];

        foreach ($this->columns as $propertyName => $columnName) {
            $reflectionProperty = new ReflectionProperty($this, $propertyName);

            $type = $reflectionProperty->getType()->getName();
            $allowsNull = $reflectionProperty->getType()->allowsNull();

            $properties[$columnName] = new Property($columnName, $type, $allowsNull);
        }

        $statement = $this->database->query()
            ->table($this->table)
            ->ifNotExists($ifNotExists)
            ->properties($properties)
            ->primaryKey($this->getPrimaryKeyColumnName())
            ->primaryKeyAutoGenerated($this->primaryKeyAutoGenerated)
            ->createTable();

        return $statement;
    }

    public function testValidate(bool $runOnInsertOrUpdateFirst = false): ?string
    {
        /**
         * Returns null if no error is detected
         * 
         * Returns the error message as a string if the validate data function failed
         * 
         * If a generic false is returned the method return 'data invalid'
         */

        if ($runOnInsertOrUpdateFirst) {
            $this->onInsertOrUpdate();
        }

        try {
            $valid = $this->validate();

            if (!$valid) {
                throw new ValidationException(
                    sprintf(
                        'data invalid for model: %s',
                        ($this::class)
                    )
                );
            }

            return null;
        } catch (Throwable $err) {
            return $err->getMessage();
        }
    }

    public function getRelation(string $name, callable $modifyQuery = null): null|Model|array
    {
        if (!key_exists($name, $this->relations)) {
            throw new RelationException(sprintf('relation with model %s does not exist', $name));
        }

        return $this->relations[$name]
            ->retrieve($this->database, $this, $modifyQuery);
    }

    public function formatProperties(): static
    {
        foreach ($this->columns as $propertyName => $columnName) {
            if (!(new ReflectionProperty($this, $propertyName))->isInitialized($this)) {
                continue;
            }

            $this->formatProperty($propertyName);
        }

        return $this;
    }

    protected function onInsertOrUpdate(): void
    {
        /**
         * Override in model
         * 
         * Use this function for properties that should be modified on insert or save
         */
    }

    protected function validate(): bool
    {
        /**
         * If the data is valid return true
         * 
         * If the data is invalid you have two options:
         * 1) Return false to silently let the process fail
         * 2) Throw an exception to notify the user something went wrong
         * 
         * Tip:
         * You can correct data on the fly in this method, but it is recommended
         * to use onInsertOrUpdate for that
         */

        return true;
    }

    protected function getColumns($includePk = false): array
    {
        $values = [];

        foreach ($this->columns as $propertyName => $columnName) {
            if (
                (!$includePk)
                &&
                ($propertyName == $this->primaryKeyPropertyName)
            ) {
                continue;
            }

            if (!(new ReflectionProperty($this, $propertyName))->isInitialized($this)) {
                continue;
            }

            $this->formatProperty($propertyName);

            $key = $columnName;
            $value = $this->{$propertyName};

            $values[$key] = $value;
        }

        return $values;
    }

    protected function formatProperty(string $propertyName): void
    {
        $value = $this->{$propertyName};

        $onSaveFunc = $this->onSave[$propertyName] ?? null;
        if (!$onSaveFunc) {
            return;
        }

        if (is_array($onSaveFunc)) {
            $this->{$propertyName} = $onSaveFunc($value);
            return;
        }

        if (method_exists($this, $onSaveFunc)) {
            $this->{$propertyName} = $this->{$onSaveFunc}($value);
            return;
        }

        if (function_exists($onSaveFunc)) {
            $this->{$propertyName} = $onSaveFunc($value);
            return;
        }
    }

    protected function getColumnType(PDOStatement $statement, array $data, string $key): ?string
    {
        $index = 0;
        foreach ($data as $columnName => $columnValue) {
            if ($columnName == $key) {
                return $statement->getColumnMeta($index)['native_type'];
            }

            $index++;
        }
    }

    protected function castFromDatabaseToModel(string $nativeType, mixed $value): mixed
    {
        if (!$this->queryBuilder) {
            $this->queryBuilder = $this->database->getQueryBuilder();
        }

        return $this->queryBuilder->castFromDatabase($nativeType, $value);
    }

    protected function castFromModelToDatabase(mixed $value): mixed
    {
        if (!$this->queryBuilder) {
            $this->queryBuilder = $this->database->getQueryBuilder();
        }

        return $this->queryBuilder->castToDatabase($value);
    }

    protected function registerRelations(): void
    {
        /**
         * Override in model
         */
    }

    protected function registerRelation(Relation $relation, ?string $nameOverride = null): void
    {
        $relationName = $nameOverride ?? $relation->relationModel::getTable();

        $this->relations[$relationName] = $relation;
    }
}
